1、
当子类中没有显式调用父类带参构造方法时，则默认调用无参构造方法，即创建子类对象后首先执行super（）。
多重继承关系下的初始化顺序：父类属性-->父类构造方法-->子类属性-->子类构造方法
2、
public Student(int age){
	this.setAge(age);//构造方法可以调用方法进行传入值的验证
	}
public void setAge(int age) {
	if (age < 18 || age > 30) {
		System.out.println("学员年龄应该在18-30岁之间,设置为默认值18。");
		this.age = 20;
		return;//结束方法
	}
	this.age = age;
}
3、static关键字：
static可以修饰属性（静态属性）、修饰方法（静态方法）、修饰代码块，不能修饰变量！！。
static修饰的部分从属于所在类，在所在类被加载时即被执行，不受所在位置的影响。
4.不能被继承的父类成员:
（1）private成员  
（2）子类与父类不在同包，使用默认访问权限的成员  
（3）构造方法
5、方法重写的规则
  在有继承关系的子类中：
（1）方法名相同；
（2）参数列表相同；
（3）返回值类型相同，或者是其子类；
（4）访问权限不能严于父类；
6、final关键字
（1）修饰类时，该类无法被继承，比如String类；public final class Penguin（）{}；
（2）修饰方法时，该方法可以被子类继承但是该方法无法在子类中被重写；
（3）修饰属性时，属性值不能被修改（常量）
     常量命名时为全大写字母，如果为多个单词则用“_”进行连接（SEX_MALE）；
     使用final修饰引用型变量，变量的值（引用型变量空间地址）是固定不变的，
     而变量所指向的对象的属性值是可变的。
7、多态：同一个引用类型。使用不同的实例执行不同的操作。（父类引用，子类对象）
  实现多态的两个要素：（1）子类重写父类方法（2）使用父类类型创建子类的对象，执行子类重写的操作
  向上转型 [父类]Pet pet = new Dog() [子类]，自动类型转换
  向下转型 pet=(Dog)pet
  ClassCastException，类型转换异常
  instanceof运算符判断对象的真实类型
  （现有对象名pet） instanceof （Dog预期转换成的类型)，表达式成立时返回true
  前后如果不存在继承关系，则编译错误（选择题中可能出现）
  8、接口（interface）中不存在构造方法！接口中必须是抽象方法
  9、在接口中可以定义抽象方法 表示对象具有的能力，
     也可以定义静态常量值，(public static final)可以省略，默认自带。
  10.数字转字符串
     String str = new Integer(num).toString();
     字符串转数字
     int num = Integer.pareseInt(String str);
  11、抽象类中抽象方法声明异常，其子类继承后可以根据需要确定是否在重写方法中声明异常。
      子类重写父类抽象方法时如果声明异常，则父类的抽象方法必须事先声明异常。